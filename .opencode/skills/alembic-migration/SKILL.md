---
name: alembic-migration
description: Create and manage Alembic database migrations for SQLAlchemy models
---

# Alembic Migration Workflow

Guide for creating and managing database migrations in the Reva project.

## Directory Structure

```
apps/api/
├── alembic/
│   ├── versions/          # Migration files
│   ├── env.py             # Alembic environment config
│   └── script.py.mako     # Migration template
├── alembic.ini            # Alembic configuration
└── app/models/            # SQLAlchemy models
```

## Commands

All commands run from `apps/api/` directory.

### Generate Migration (Auto)

```bash
cd apps/api
uv run alembic revision --autogenerate -m "description of changes"
```

### Generate Migration (Manual)

```bash
cd apps/api
uv run alembic revision -m "description of changes"
```

### Apply Migrations

```bash
# Apply all pending migrations
uv run alembic upgrade head

# Apply specific migration
uv run alembic upgrade <revision_id>

# Apply next migration only
uv run alembic upgrade +1
```

### Rollback Migrations

```bash
# Rollback one migration
uv run alembic downgrade -1

# Rollback to specific revision
uv run alembic downgrade <revision_id>

# Rollback all migrations
uv run alembic downgrade base
```

### Check Status

```bash
# Show current revision
uv run alembic current

# Show migration history
uv run alembic history

# Show pending migrations
uv run alembic history --indicate-current
```

## Migration File Structure

```python
"""description of changes

Revision ID: abc123
Revises: def456
Create Date: 2024-01-01 12:00:00.000000
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision: str = 'abc123'
down_revision: Union[str, None] = 'def456'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Add upgrade operations here
    op.create_table(
        'table_name',
        sa.Column('id', sa.UUID(), primary_key=True),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.func.now()),
    )


def downgrade() -> None:
    # Add downgrade operations here
    op.drop_table('table_name')
```

## Common Operations

### Create Table

```python
op.create_table(
    'products',
    sa.Column('id', sa.UUID(), primary_key=True, server_default=sa.text('gen_random_uuid()')),
    sa.Column('organization_id', sa.UUID(), sa.ForeignKey('organizations.id', ondelete='CASCADE'), nullable=False),
    sa.Column('name', sa.String(255), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now()),
)
```

### Add Column

```python
op.add_column('products', sa.Column('sku', sa.String(100), nullable=True))
```

### Add Index

```python
# Regular index
op.create_index('ix_products_sku', 'products', ['sku'])

# Unique index
op.create_index('ix_products_org_sku', 'products', ['organization_id', 'sku'], unique=True)

# Partial index
op.create_index(
    'ix_products_active',
    'products',
    ['organization_id'],
    postgresql_where=sa.text('is_active = true')
)
```

### Add Foreign Key

```python
op.create_foreign_key(
    'fk_products_organization',
    'products', 'organizations',
    ['organization_id'], ['id'],
    ondelete='CASCADE'
)
```

### pgvector Index (for embeddings)

```python
# IVFFlat index for approximate nearest neighbor search
op.execute('''
    CREATE INDEX ix_knowledge_chunks_embedding
    ON knowledge_chunks
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100)
''')
```

## Naming Conventions

| Object       | Pattern                | Example                    |
| ------------ | ---------------------- | -------------------------- |
| Table        | `snake_case` plural    | `knowledge_chunks`         |
| Column       | `snake_case`           | `organization_id`          |
| Primary Key  | `id`                   | `id`                       |
| Foreign Key  | `fk_{child}_{parent}`  | `fk_products_organization` |
| Index        | `ix_{table}_{columns}` | `ix_products_sku`          |
| Unique Index | `uq_{table}_{columns}` | `uq_products_org_sku`      |

## Best Practices

1. **Always ask before applying migrations** - Never run `alembic upgrade` without explicit user confirmation
2. **Always review autogenerated migrations** - They may miss custom operations
3. **Test both upgrade and downgrade** - Ensure rollback works
4. **Use nullable=True for new columns** on existing tables (or provide default)
5. **Create indexes concurrently** for large tables in production
6. **Data migrations** - Separate from schema migrations when possible
7. **Never edit applied migrations** - Create new migration instead
